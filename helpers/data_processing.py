"""
CardioTRaNs 2019
Author: Rohit Suratekar

All functions related to Data Processing and Normalization
"""

import csv
from collections import defaultdict

from constants import *
from models.biology import Factor, RegulationLink, Expression


def get_factors() -> dict:
    """
    Extracts Targets from INPUT_FILE_FACTORS file (.csv)

    INPUT_FILE_FACTORS file should have following columns (in following order)
    1) UID:int - Unique ID of given factor in the database
    2) Factor:str - Symbol of the factor
    3) Organism:str - From which organism this factor is taken
    4) ZFIN:str - ZFIN ID (https://zfin.org/) (None if it is from other
    organism)
    5) Type:str - Type of factor (e.g. TF, protein)
    6) Zebrafish Homolog:int - Respective Zebrafish homolog or ortholog UID (
    0 if it is zebrafish factor)

    For Example,
    1,  nkx2.5, Zebrafish,  ZDB-GENE-980526-321,    TF, 0

    :return: Dictionary of all factors where their UID is the key
    :raises: ValueError: When UID is not integer
    """

    factors = {}
    with open("{}/{}".format(DATA_FOLDER, INPUT_FILE_FACTORS)) as f:
        data = csv.reader(f)  # Reads the file
        next(data)  # Skip the header
        for line in data:
            f = Factor(line)
            factors[f.uid] = f

    return factors


def get_regulatory_links(return_map: bool = False):
    """
    Extracts regulatory links from INPUT_FILE_TARGETS file (.csv)

    This file do not support Double Mutants

    INPUT_FILE_TARGETS file should have following columns (in following order)
    1) Factor UID:int - UID of the factor
    2) Name:str - Symbol of the factor
    3) Target UID:int - UID of the target
    4) Target:str - Symbol of the target
    5) Regulation:Str - Type of regulation (Positive, Negative or Effectless)
    6) Place:Str - Tissue or Organ where the effect is taking place
    7) Stage:Str - Reported/or calculated developmental stage
    8) Corrected Stage:str - Corrected stage to fit into standard
    developmental stages provided in ZFIN data-set
    https://zfin.org/zf_info/zfbook/stages/index.html
    9) Time:float - Time period (in hours) of the corrected stage
    10) Experiment:str - Type of experiment
    11) Reference:str - PubMed ID of the reference paper
    12) Notes:str - Other details (if any)

    :param return_map: If True, will return factor generated by `get_factors()`
    :return: List of TargetLinks
    """

    factor_map = get_factors()
    links = []
    with open("{}/{}".format(DATA_FOLDER, INPUT_FILE_TARGETS)) as f:
        data = csv.reader(f)  # Reads the file
        next(data)  # Skip the header
        for line in data:
            links.append(RegulationLink(line, factor_map))

    if return_map:
        return links, factor_map
    else:
        return links


def get_expression_data(return_map: bool = False):
    """
    Extracts expression data from INPUT_FILE_EXPRESSION (.csv)

    INPUT_FILE_EXPRESSION file should have following columns(in following order)
    1) UID:int - Unique ID of given factor in the database
    2) Factor:str - Symbol of the factor
    3) Place:Str - Tissue or Organ where the effect is taking place
    4) Stage:Str - Reported/or calculated developmental stage
    5) Corrected Stage:str - Corrected stage to fit into standard
    developmental stages provided in ZFIN data-set
    https://zfin.org/zf_info/zfbook/stages/index.html
    6) Time:float - Time period (in hours) of the corrected stage
    7) Experiment:str - Type of experiment
    8) Reference:str - PubMed ID of the reference paper
    9) Notes:str - Other details (if any)

    :param return_map: If True, will return factor generated by `get_factors()`
    :return: Dictionary containing list of all expression data
    """

    factor_map = get_factors()
    pattern = defaultdict(list)
    with open("{}/{}".format(DATA_FOLDER, INPUT_FILE_EXPRESSION)) as f:
        data = csv.reader(f)  # Reads the file
        next(data)  # Skip the header
        for line in data:
            e = Expression(line, factor_map)
            pattern[e.factor.uid].append(e)

    if return_map:
        return pattern, factor_map
    else:
        return pattern


def run():
    pass
